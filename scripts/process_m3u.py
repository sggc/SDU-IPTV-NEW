#!/usr/bin/env python3
import requests
import re
import hashlib
import os
from datetime import datetime

# ==================== 需要您修改的配置 ====================
SOURCE_M3U_URL = "https://raw.githubusercontent.com/plsy1/iptv/refs/heads/main/unicast.m3u"
OUTPUT_FILENAME = "playlist.m3u"
# 存储源文件hash的文件
HASH_FILE = "source_hash.txt"
# =======================================================

class M3UProcessor:
    def __init__(self, source_url, output_file, hash_file):
        self.source_url = source_url
        self.output_file = output_file
        self.hash_file = hash_file
        self.channels = []
    
    def get_content_hash(self, content):
        """计算内容的MD5哈希值"""
        return hashlib.md5(content.encode('utf-8')).hexdigest()
    
    def get_previous_hash(self):
        """获取之前保存的源文件哈希值"""
        if os.path.exists(self.hash_file):
            with open(self.hash_file, 'r', encoding='utf-8') as f:
                return f.read().strip()
        return None
    
    def save_current_hash(self, content):
        """保存当前源文件的哈希值"""
        current_hash = self.get_content_hash(content)
        with open(self.hash_file, 'w', encoding='utf-8') as f:
            f.write(current_hash)
        return current_hash
    
    def has_source_changed(self, content):
        """检查源文件是否发生变化"""
        current_hash = self.get_content_hash(content)
        previous_hash = self.get_previous_hash()
        
        if previous_hash is None:
            print("首次运行，没有之前的哈希记录")
            return True
        
        if current_hash == previous_hash:
            print("源文件没有变化，跳过处理")
            return False
        else:
            print(f"源文件发生变化: 旧哈希 {previous_hash[:8]}... -> 新哈希 {current_hash[:8]}...")
            return True
    
    def download_file(self):
        """下载M3U文件"""
        print(f"下载M3U文件从: {self.source_url}")
        response = requests.get(self.source_url)
        response.raise_for_status()
        return response.text
    
    def parse_m3u(self, content):
        """解析M3U文件内容"""
        self.channels = []
        lines = content.split('\n')
        current_channel = {}
        
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
                
            if line.startswith('#EXTM3U'):
                continue
                
            if line.startswith('#EXTINF:'):
                if current_channel and current_channel.get('url'):
                    self.channels.append(current_channel)
                
                current_channel = {
                    'extinf': line,
                    'url': None,
                    'name': self.extract_channel_name(line),
                    'original_index': len(self.channels)
                }
            elif not line.startswith('#') and current_channel:
                current_channel['url'] = line
                self.channels.append(current_channel)
                current_channel = {}
        
        if current_channel and current_channel.get('url'):
            self.channels.append(current_channel)
    
    def extract_channel_name(self, extinf_line):
        """从EXTINF行提取频道名称"""
        match = re.search(r',([^,]+)$', extinf_line)
        if match:
            return match.group(1).strip()
        return ""
    
    def find_channel_index(self, keywords):
        """根据关键词查找频道索引"""
        for i, channel in enumerate(self.channels):
            if any(keyword in channel['name'] for keyword in keywords):
                return i
        return -1
    
    def move_channel_after_target(self, source_keywords, target_keywords):
        """将源频道移动到目标频道后面"""
        shandong_idx = self.find_channel_index(source_keywords)
        cctv4k_idx = self.find_channel_index(target_keywords)
        
        if shandong_idx == -1:
            print(f"警告: 未找到包含 {source_keywords} 的频道")
            return False
        
        if cctv4k_idx == -1:
            print(f"警告: 未找到包含 {target_keywords} 的频道")
            return False
        
        print(f"找到山东卫视: 位置 {shandong_idx}, 频道名: {self.channels[shandong_idx]['name']}")
        print(f"找到CCTV4K: 位置 {cctv4k_idx}, 频道名: {self.channels[cctv4k_idx]['name']}")
        
        if shandong_idx == cctv4k_idx + 1:
            print("山东卫视已经在CCTV4K后面，无需移动")
            return True
        
        shandong_channel = self.channels.pop(shandong_idx)
        
        if shandong_idx < cctv4k_idx:
            cctv4k_idx -= 1
        
        insert_position = cctv4k_idx + 1
        self.channels.insert(insert_position, shandong_channel)
        
        print(f"已将山东卫视移动到CCTV4K后面 (新位置: {insert_position})")
        return True
    
    def generate_m3u_content(self):
        """生成新的M3U内容"""
        header = f"""#EXTM3U
# Generated by GitHub Actions
# Source: {self.source_url}
# Processed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# 山东卫视已移动到CCTV4K频道后面

"""
        
        content = header
        for channel in self.channels:
            content += channel['extinf'] + '\n'
            content += channel['url'] + '\n'
        
        return content
    
    def process(self):
        """主处理流程"""
        try:
            # 下载源文件
            content = self.download_file()
            
            # 检查源文件是否发生变化
            if not self.has_source_changed(content):
                print("源文件没有变化，跳过处理")
                # 创建空文件或保持原文件
                if not os.path.exists(self.output_file):
                    with open(self.output_file, 'w', encoding='utf-8') as f:
                        f.write("# 源文件没有变化，保持原样\n")
                return True
            
            # 解析和处理内容
            self.parse_m3u(content)
            print(f"解析完成，共 {len(self.channels)} 个频道")
            
            # 移动频道
            success = self.move_channel_after_target(
                source_keywords=['山东卫视', '山东台'],
                target_keywords=['CCTV4K', 'CCTV-4K']
            )
            
            # 生成新内容并保存
            new_content = self.generate_m3u_content()
            with open(self.output_file, 'w', encoding='utf-8') as f:
                f.write(new_content)
            
            # 保存当前哈希值
            self.save_current_hash(content)
            
            print(f"处理完成，已保存到 {self.output_file}")
            return True
            
        except Exception as e:
            print(f"处理过程中出错: {e}")
            import traceback
            traceback.print_exc()
            return False

def main():
    processor = M3UProcessor(SOURCE_M3U_URL, OUTPUT_FILENAME, HASH_FILE)
    success = processor.process()
    
    if not success:
        print("处理失败")
        exit(1)

if __name__ == "__main__":
    main()
